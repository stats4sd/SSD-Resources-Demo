<!--additional required imports vulcanized in import-core.html-->
<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="shared-styles.html">

<dom-module id="ssd-resources">
  <template>
    <style include="shared-styles">
       :host {
        display: block;
        padding: 10px;
      }

      h1 {
        margin: 0
      }

      .resource-page-body {
        display: flex;
        min-height: 100vh;
        flex-direction: column;
      }

      .resource-page-content {
        display: flex;
        flex: 1;
      }

      .main-content {
        flex: 1;
      }

      .left-sidebar-nav,
      .right-sidebar-aside {
        /* 12em is the width of the columns */
        flex: 0 0 12em;
      }

      .left-sidebar-nav {
        /* put the nav on the left */
        order: -1;
        align-self: center;
      }

      .slider {
        position: relative;
        background-color: #ccc;
        height: 300px;
        overflow-x: scroll;
        overflow-y: hidden;
      }

      .track {
        position: absolute;
        top: 10px;
        left: 10px;
        margin: 0;
        padding: 0;
        border: 0;
        width: 2400px;
      }

      .section-heading {
        font-size: 1.6em;
        font-weight: 600;
      }
    </style>
    <app-route route="{{route}}" pattern="/:resourceSlug" data="{{_routeData}}"></app-route>

    <!--sets up 3 column view (aside not currently used),
    sized and ordered through flex css (fixed sidebar, full width main-->
    <!--uses ideas from http://philipwalton.github.io/solved-by-flexbox/demos/holy-grail/
    and http://jsfiddle.net/V2x6s/3/-->

    <body class="resource-page-body">
      <div class="resource-page-content">
        <!--main section-->
        <main class="main-content">
          <div class="mobile-section-heading section-heading" hidden$={{veryWide}}>
            Latest Resources
          </div>
          <div class="slider">
            <div class="track" id="track1">
              <template id="resourceList" is="dom-repeat" items="[[persistedNewestResources]]" as="resource" sort="_sortNewest">
                <ssd-resource-small resource='[[resource]]' hidden$="[[resource.deleted]]" on-tap='resourceTap'></ssd-resource-small>
              </template>
            </div>
          </div>
        </main>
        <!--left sidebar-->
        <nav class="left-sidebar-nav" hidden$={{!veryWide}}>
          <div class="section-heading">Latest Resources</div>
        </nav>
        <!--right sidebar (not used)-->
        <!--<aside class="right-sidebar-aside">aside</aside>-->
      </div>
    </body>

    <!--  SETTING UP RESOURCES 2 versions, one if running live and one if loading from cache -->
    <ssd-resource-full hidden$="[[liveResourceMode]]" id="fullResource" resource='[[selectedResource]]' opened='{{resourceOpened}}'
      signed-in='{{signedIn}}' persisted-tags="[[persistedTags]]" on-update="updateFired">
    </ssd-resource-full>
    <ssd-resource-full hidden$="[[!liveResourceMode]]" id="liveResource" resource='[[liveResourceDoc]]' opened='{{resourceOpened}}'
      signed-in='{{signedIn}}' persisted-tags="[[persistedTags]]" on-update="updateFired">
    </ssd-resource-full>

    <!--<ssd-search id="search" route="{{route}}" filtered-resources="[[persistedResources]]" all-resources="[[persistedResources]]"
      persisted-tags="[[persistedTags]]" search-opened="{{searchOpened}}" search-text="{{searchText}}">
    </ssd-search>-->

    <!--Firebase queries-->
    <!--query to pull in tags as doesn't update well in live mode on tags page (want import before load)-->
    <firebase-query id="query" app-name="SSD-Resources" path="/tags" data="{{alltags}}"></firebase-query>
    <app-indexeddb-mirror key="persistedTags" data="{{alltags}}" persisted-data="{{persistedTags}}" session="keepAlways"></app-indexeddb-mirror>
    <!-- FIREBASE QUERY TO PULL IN RESOURCES FROM DB, starts after load  -->
    <firebase-query id="query" app-name="SSD-Resources" path="[[allResourcesPath]]" data="{{resources}}"></firebase-query>
    <app-indexeddb-mirror key="persistedResources" data="{{resources}}" persisted-data="{{persistedResources}}" session="keepAlways"></app-indexeddb-mirror>
    <!-- FIREBASE QUERY TO PULL IN newest FROM DB, starts before load  -->
    <firebase-query id="query" app-name="SSD-Resources" path="/resources" data="{{newestResources}}" limit-to-last="20"></firebase-query>
    <app-indexeddb-mirror key="persistedNewestResources" data="{{newestResources}}" session="keepAlways" persisted-data="{{persistedNewestResources}}"></app-indexeddb-mirror>
    <!--Firebase documents to load specific resource from slug. One doc to pull correct full id and other to load. 
    only used if no persisted resource (e.g. initial resource load direct from link)-->
    <firebase-document id="query" app-name="SSD-Resources" path="/slugs/[[resourceSlug]]" data="{{slugDoc}}"></firebase-document>
    <firebase-document id="query" app-name="SSD-Resources" path="/resources/[[liveResourceID]]" data="{{liveResourceDoc}}"></firebase-document>
  </template>

  <script>
    Polymer({
      is: 'ssd-resources',
      //when core loaded, load click-through elements and setup firebase queries
      ready: function () {

      },

      properties: {
        resourceOpened: {
          type: Boolean,
          value: false,
          notify: true,
          observer: 'resourceOpenChange'
        },
        resources: {
          type: Object,
          notify: true,
        },
        persistedResources:{
          type:Object,
          notify:true,
        },
        persistedTags: {
            type: Object,
            notify: true,
          },
        tagActive: {
          type: Boolean,
          value: false
        },
        filter_tags: {
          type: Object,
          observer: 'filterChange',
          value: []
        },
        selectedResource: {
          type: Object,
          value: [],
          notify: true
        },
        editMode: {
          type: Boolean,
          value: false,
          notify: true,
        },
        liveMode: {
          type: Boolean,
          value: false
        },
        searchOpened: {
          type: Boolean,
          value: false
        },
        _routeData: {
          type: Object,
          observer: 'routeChange'
        },
        slugDoc: {
          type: Object,
          observer: 'slugDocRetrieved'
        },
        liveResourceID: {
          type: String,
          value: '_empty'
        },
        signedIn: {
          type: Boolean,
          notify: true
        },
        page: {
          type: String,
          observer: '_pageChanged',
          notify: true
        },
        lazyLoadComplete: {
          type: Boolean
        },
        persistedTags: {
          type: Object,
          notify: true,
        },
        searchOpened: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true
        },
        searchText: {
          type: String,
          notify: true,
          reflectToAttribute: true,
          value:""
        },
      },
      // observers:[],
      ready: function () {
        this.allResourcesPath = "/resources"
        console.log('downloading all resources')
        // ***
        // would be good to somehow use transactions-complete or similar promise to know when query finished
      },

      routeChange: function (newRoute, oldRoute) {
        if (newRoute.resourceSlug == "") {
          //close resource on back navigation
          this.set('resourceOpened', false)
        }
        if (newRoute.resourceSlug && newRoute.resourceSlug.length > 0) {
          //if already loaded via click don't bother
          if (this.selectedResource.slug && this.selectedResource.slug == newRoute.resourceSlug) {}
          else {
            this.loadResource(newRoute.resourceSlug)
          }
        }
      },
      resourceOpenChange: function (newState, oldState) {
        if (newState == false) {
          //resource has been closed
          this.set('route.path', '/')
        }
      },

      loadResource: function (slug) {
        if (this.persistedResources && this.persistedResources.length > 0) {
          console.log('persistedResources', this.persistedResources)
          console.log('attempting to load from cache')
          // load it
          var found = false
          for (var i = 0; i < this.persistedResources.length; i++) {
            console.log('testing', this.persistedResources[i].slug, 'for', slug)
            if (this.persistedResources[i].slug == slug) {
              //match found in persited resources
              console.log('match found', this.persistedResources[i])
              this.liveResourceMode = false;
              this.$.fullResource.open(this.persistedResources[i]);
              found = true
              return
            }
          }
        }
        else {
          console.log('attempting to load live version')
          this.resourceSlug = slug
          this.liveResourceMode = true
        }
      },

      slugDocRetrieved: function (doc) {
        //should pull id as string or object length 20
        if (Object.keys(doc).length > 0) {
          console.log('slugDocRetrieved', doc)
          this.liveResourceID = doc
          console.log('opening live resource')
          this.$.liveResource.open();
        }
      },

      updateFired: function (message) {
        console.log('res updated')
        //this.$.resourceList2.render()
        this.liveMode = true
      },
      resourceTap: function (e) {
        this.set('selectedResource', e.model.resource)
        this.$.fullResource.open(this.selectedResource);
        this.liveResourceMode = false;
        this.set('route.path', e.model.resource.slug)
      },
      _pageChanged: function (page) {
        if (this.page == "resources" && this.lazyLoadComplete == false) {
          console.log('starting lazy load')
          Polymer.RenderStatus.afterNextRender(this, () => {
            this.importHref(
              this.resolveUrl('imports-lazy-resources.html'),
              function (success) {
                this.lazyLoadComplete = true;
                console.log('lazy resources successful import')
              },
              function (err) { console.log('error importing lazy resources', err) },
              true);
          });
        }
      },
      //responds to calls from add resource button and passes empty request to resource open
      addResource: function () {
        //hide live editor if present
        this.liveResourceMode = false
        this.$.fullResource.open('new');
      },
      getResource: function (id) {
        console.log('getting resource', id)
        console.log('resources', this.allR)
      },
      filterChange: function () {
        console.log('filters updated')
        var temp = this.persistedResources
        var filtersList = ['topics', 'rTypes', 'tags']
        this.activeFilters = {}
        //populate filter list with currently selected - should be moved out to only calculate on change
        for (var i = 0; i < filtersList.length; i++) {
          var string = 'filter_' + filtersList[i];
          if (this[string] != undefined && this[string] != '') {
            if (this[string] != "(all)") {
              this.activeFilters[filter] = this[string];
            }
          }
        }
        this.persistedResources = []
        this.persistedResources = temp
      },

      _sortNewest: function (a, b) {
        if (a.created > b.created) { return -1 }
        else { return 1 }
      },
      _return: function (value) {
        return value;
      }

    });
  </script>
</dom-module>