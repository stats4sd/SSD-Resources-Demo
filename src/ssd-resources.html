<!--additional required imports vulcanized in import-core.html-->
<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="shared-styles.html">

<dom-module id="ssd-resources">
  <template>
    <style include="shared-styles">
       :host {
        display: block;
      }

      h1 {
        margin: 0
      }

      .resource-page-body {
        display: flex;
        min-height: 100vh;
        flex-direction: column;
      }

      .resource-page-content {
        display: flex;
        flex: 1;
      }

      .main-content {
        flex: 1;
      }

      .left-sidebar-nav,
      .right-sidebar-aside {
        /* 12em is the width of the columns */
        flex: 0 0 12em;
      }

      .left-sidebar-nav {
        /* put the nav on the left */
        order: -1;
        align-self: center;
      }

      .slider {
        position: relative;
        background-color: #ccc;
        height: 300px;
        overflow-x: scroll;
        overflow-y: hidden;
      }

      .track {
        position: absolute;
        top: 10px;
        left: 10px;
        margin: 0;
        padding: 0;
        border: 0;
        width: 2400px;
      }

      .section-heading {
        font-size: 1.6em;
        font-weight: 600;
      }
    </style>
    <app-route route="{{route}}" pattern="/:resourceSlug" data="{{_routeData}}"></app-route>

    <!--sets up 3 column view (aside not currently used),
    sized and ordered through flex css (fixed sidebar, full width main-->
    <!--uses ideas from http://philipwalton.github.io/solved-by-flexbox/demos/holy-grail/
    and http://jsfiddle.net/V2x6s/3/-->

    <body class="resource-page-body">
      <div class="resource-page-content">
        <!--main section-->
        <main class="main-content">
          <div class="mobile-section-heading section-heading" hidden$={{veryWide}}>
            Latest Resources
          </div>
          <div class="slider">
            <div class="track" id="track1">
              <template id="resourceList" is="dom-repeat" items="[[persistedNewestResources]]" as="resource" sort="_sortNewest">
                <ssd-resource-small resource='[[resource]]' hidden$="[[resource.deleted]]" on-tap='resourceTap'></ssd-resource-small>
              </template>
            </div>
          </div>
          <!--temp section-->
          <div>
            [[serverSearch]]
          </div>
        </main>
        <!--left sidebar-->
        <nav class="left-sidebar-nav" hidden$={{!veryWide}}>
          <div class="section-heading">Latest Resources</div>
        </nav>
        <!--right sidebar (not used)-->
        <!--<aside class="right-sidebar-aside">aside</aside>-->
      </div>
    </body>

    <!--  SETTING UP RESOURCES -->
    <ssd-resource-full id="fullResource" resource='[[selectedResource]]' opened='{{resourceOpened}}' signed-in='{{signedIn}}'
      persisted-tags="[[persistedTags]]" on-update="updateFired">
    </ssd-resource-full>
    <ssd-search id="search" route="{{route}}" filtered-resources="[[persistedResources]]" all-resources="[[persistedResources]]"
      persisted-tags="[[persistedTags]]" search-opened="{{searchOpened}}" search-text="{{searchText}}">
    </ssd-search>

    <!--Firebase queries-->
    <!--query to pull in tags as doesn't update well in live mode on tags page (want import before load)-->
    <firebase-query id="query" app-name="SSD-Resources" path="/tags" data="{{alltags}}"></firebase-query>
    <app-indexeddb-mirror key="persistedTags" data="{{alltags}}" persisted-data="{{persistedTags}}" session="keepAlways"></app-indexeddb-mirror>
    <!-- FIREBASE QUERY TO PULL IN RESOURCES FROM DB, starts after load  -->
    <firebase-query id="query" app-name="SSD-Resources" path="[[allResourcesPath]]" data="{{resources}}"></firebase-query>
    <app-indexeddb-mirror key="persistedResources" data="{{resources}}" persisted-data="{{persistedResources}}" session="keepAlways"
      transactions-complete="persistedComplete" log="true"></app-indexeddb-mirror>
    <!-- FIREBASE QUERY TO PULL IN newest FROM DB, starts before load  -->
    <firebase-query id="query" app-name="SSD-Resources" path="/resources" data="{{newestResources}}" limit-to-last="20"></firebase-query>
    <app-indexeddb-mirror key="persistedNewestResources" data="{{newestResources}}" session="keepAlways" persisted-data="{{persistedNewestResources}}"></app-indexeddb-mirror>
    <!--Firebase document for specific resource id from slug. Not needed as won't be making live query to firebase document afterwards (want function from persisted if possible)-->
    <!--<firebase-document id="query" app-name="SSD-Resources" path="/slugs/[[resourceSlug]]" data="{{resourcesDoc}}"></firebase-document>-->
  </template>

  <script>
    Polymer({
      is: 'ssd-resources',
      //when core loaded, load click-through elements and setup firebase queries
      ready: function () {

      },

      properties: {
        resourceOpened: {
          type: Boolean,
          value: false,
          notify: true
        },
        resources: {
          type: Object,
          notify: true,
        },
        tagActive: {
          type: Boolean,
          value: false
        },
        filter_tags: {
          type: Object,
          observer: 'filterChange',
          value: []
        },
        selectedResource: {
          type: Object,
          value: [],
          notify: true
        },
        editMode: {
          type: Boolean,
          value: false,
          notify: true,
        },
        liveMode: {
          type: Boolean,
          value: false
        },
        searchOpened: {
          type: Boolean,
          value: false
        },
        resourcesSlug: {
          type: String,
          value: '_no-resource-here'
        },
        resourceSlug: {
          type: String,
          computed: '_return(_routeData.resourceSlug)',
          observer: 'ResourceSlugChange'
        },
        resourceFromUrl: {
          type: Object,
          computed: '_getResourceFromURL(resourcesDoc)'
        },
        computedResource: {
          type: Object,
          computed: '_getResourceBySlug(persistedResources)'
        },
        resourcesDoc: {
          type: Object,
          notify: true,
        },
        signedIn: {
          type: Boolean,
          notify: true
        },
        page: {
          type: String,
          observer: '_pageChanged',
          notify: true
        },
        lazyLoadComplete: {
          type: Boolean
        },
        persistedTags: {
          type: Object,
          notify: true,
        },
        searchOpened: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true
        },
        searchText: {
          type: String,
          notify: true,
          reflectToAttribute: true
        },
      },
      // observers:[
      //   'serverSearch2(serverSearch.*)'
      //   ],
      ready: function () {
        this.allResourcesPath = "/resources"
        console.log('downloading all resources')
      },
      created: function () {
        this.persistedComplete = new Promise(
          // The resolver function is called with the ability to resolve or
          // reject the promise
          (resolve, reject) => {
            log.insertAdjacentHTML('beforeend', thisPromiseCount +
              ') Promise started (<small>Async code started</small>)<br/>');
            // This is only an example to create asynchronism
            window.setTimeout(
              function () {
                // We fulfill the promise !
                resolve(thisPromiseCount);
              }, Math.random() * 2000 + 1000);
          }
        );
      },

      ResourceSlugChange: function (slug) {
        console.log('slug changed', slug)
        this.resourceSlug = slug;
        this.selectedResource = this._getResourceBySlug(this.persistedResources)
        console.log('selected resource', this.selectedResource)
      },

      _getResourceBySlug: function (persistedResources) {
        console.log('getting resource by slug', this.resourceSlug)
        console.log('persisted resources', persistedResources)
        if (persistedResources) {
          console.log('length', persistedResources.length)
        }
        if (persistedResources && persistedResources.length > 0) {
          console.log('persistedResources', persistedResources)
          for (var i = 0; i < persistedResources.length; i++) {
            if (persistedResources[i].slug == this.resourceSlug)
              console.log('match found', persistedResources[i])
            return persistedResource[i]
          }
        }
      },
      updateFired: function () {
        console.log('res updated')
        //this.$.resourceList2.render()
        this.liveMode = true
      },
      resourceTap: function (e) {
        this.$.fullResource.open(e.model.resource);
      },
      _pageChanged: function (page) {
        if (this.page == "resources" && this.lazyLoadComplete == false) {
          console.log('starting lazy load')
          Polymer.RenderStatus.afterNextRender(this, () => {
            this.importHref(
              this.resolveUrl('imports-lazy-resources.html'),
              function (success) {
                this.lazyLoadComplete = true;
                console.log('lazy resources successful import')
              },
              function (err) { console.log('error importing lazy resources', err) },
              true);
          });
        }
      },
      //responds to calls from add resource button and passes empty request to resource open
      addResource: function () {
        this.$.fullResource.open();
      },
      getResource: function (id) {
        console.log('getting resource', id)
        console.log('resources', this.allR)
      },
      filterChange: function () {
        console.log('filters updated')
        var temp = this.persistedResources
        var filtersList = ['topics', 'rTypes', 'tags']
        this.activeFilters = {}
        //populate filter list with currently selected - should be moved out to only calculate on change
        for (var i = 0; i < filtersList.length; i++) {
          var string = 'filter_' + filtersList[i];
          if (this[string] != undefined && this[string] != '') {
            if (this[string] != "(all)") {
              this.activeFilters[filter] = this[string];
            }
          }
        }
        this.persistedResources = []
        this.persistedResources = temp
      },

      _sortNewest: function (a, b) {
        if (a.created > b.created) { return -1 }
        else { return 1 }
      },
      _return: function (value) {
        return value;
      }

    });
  </script>
</dom-module>