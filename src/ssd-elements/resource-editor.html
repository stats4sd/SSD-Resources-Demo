<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../redux-mixin.html">

<!-- <link rel="import" href="../../bower_components/polymerfire/firebase-storage-multiupload.html">
<link rel="import" href="../../bower_components/polymerfire/firebase-storage-upload-task.html"> -->
<link rel="import" href="../../bower_components/polymerfire/firebase-document.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/vaadin-combo-box/vaadin-combo-box.html">
<link rel="import" href="../../bower_components/vaadin-upload/vaadin-upload.html">
<link rel="import" href="../../bower_components/iron-icons/social-icons.html">

<link rel="import" href="../ssd-elements/resource-element.html">
<link rel="import" href="../shared-styles.html">
<link rel="import" href="../stats4sd-icons.html">


<dom-module id="resource-editor">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
        padding: 10px;
      }

      .resource-preview {
        border: 1px solid black;
        flex: 1;
        margin-left: 20px;
      }

      paper-toggle-button.preview-toggle {
        float: right;
        cursor: pointer;
        --paper-toggle-button-checked-bar-color: var(--paper-green-500);
        --paper-toggle-button-checked-button-color: var(--paper-green-500);
        --paper-toggle-button-checked-ink-color: var(--paper-green-500);
      }

      vaadin-combo-box.tag-box {
        display: block;
        width: 200px;
      }

      .keywords-list {
        margin: 10px 0;
        font-size: small;
      }

      .preview-toggle-label {
        float: right;
        font-size: small;
        padding-right: 5px;
        cursor: pointer;
      }

      .feature-image {
        width: 150px;
        height: 150px;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
      }

      .placeholder {
        border: 1px dashed black;
        border-radius: 20px;
      }
    </style>

    <!-- Firebase binding for live tag data -->
    <firebase-document id="firebaseDoc" path="[[firebaseDocPath]]" data="{{firebaseDocData}}" app-name="stats4sd-firebase"></firebase-document>

    <!-- <firebase-document id="currentTag" app-name="stats4sd-firebase" data="{{currentTag}}" path=""></firebase-document> -->
    <div style="display: flex;flex-wrap:wrap">
      <paper-card style="padding:10px; width: 400px;">
        <paper-toggle-button checked="{{previewMode}}" class="preview-toggle"></paper-toggle-button>
        <div class="preview-toggle-label" on-tap="_togglePreview">Preview</div>
        <!-- Title and Description -->
        <paper-input id="resourceName" value="{{resource.name}}" name="title" label="Title of Resource" required></paper-input>
        <span class="url">[[origin]]/[[slug]]</span>
        <p>
          <paper-textarea id="resourceDescription" value="{{resource.description}}" name="description" label="Brief Description" required
            always-float-label></paper-textarea>
        </p>

        <!-- Keywords -->
        <vaadin-combo-box class="tag-box" label="Keywords" id="keywordsCombo" items="[[allKeywordsArray]]" item-value-path="$key"
          filter="{{keywordFilterText}}" filtered-items="{{filteredKeywords}}" selected-item-changed="selectedKeywordChanged"
          allow-custom-value on-custom-value-set="_addNewKeyword" on-change="_addKeyword" value="{{selectedKeyword}}">
        </vaadin-combo-box>
        <div hidden$="[[!showAddKeywordText]]" style="margin-top:5px">Press Enter To Add Keyword:
          <strong>[[keywordFilterText]]</strong>
        </div>
        <div class="keywords-list">
          <template id="keywordsList" is="dom-repeat" as="keyword" items="[[resourceKeywordsArray]]">
            <paper-button class="keyword-button">{{keyword.label}}
              <iron-icon icon="close" on-tap="_removeKeyword" data-keyword$="[[keyword]]"></iron-icon>
            </paper-button>
          </template>
        </div>

        <!-- Resource Type-->
        <vaadin-combo-box class="tag-box" label="Resource Type" id="Resource-Types_Combo" items="[[allResourceTypesArray]]" item-label-path="label"
          item-value-path="$key" value="{{resource.type}}">
        </vaadin-combo-box>


        <!-- **************************** possibly manage collections elsewhere? ************************ -->
        <!-- External Links -->
        <div style="margin-bottom:1em">
          <h4 style="margin-bottom: 0">External Links</h4>
          <template id="externalLinks" is="dom-repeat" items="[[resource.externalLinks]]" as="link">
            <div class='flex-container'>
              <a href="{{link.url}}" target="_blank">
                <span>[[link.url]]</span>
              </a>
              <paper-icon-button suffix on-tap="editLink" class="green" icon="mode-edit" alt="edit" title="edit">
              </paper-icon-button>
              <paper-icon-button on-tap="removeLink" class="red" icon="clear" alt="clear" title="clear">
              </paper-icon-button>
            </div>
          </template>
          <form style="display:flex; align-items:center">
            <iron-icon icon="social:public" prefix style="margin-right:5px"></iron-icon>
            <paper-input id="externalLinkInput" style="flex-basis:100%" label="add external links here" no-label-float value="{{externalLinkUrl}}"></paper-input>
            <paper-icon-button suffix on-tap="_addExternalLink" style="color:green" icon="add" alt="add" title="add"></paper-icon-button>
          </form>
        </div>
        <iron-a11y-keys id="a11y" target="[[externalInputTarget]]" keys="enter" on-keys-pressed="_addExternalLink"></iron-a11y-keys>

        <!-- public/hidden Checkbox -->
        <div class="flex">
          <paper-toggle-button checked="{{resource.public}}" style="cursor: pointer"></paper-toggle-button>
          <div hidden$="[[!resource.public]]">
            <span>Public</span>
            <iron-icon icon="visibility"></iron-icon>
          </div>
          <div hidden$="[[resource.public]]">
            <span>Hidden</span>
            <iron-icon icon="visibility-off"></iron-icon>
          </div>
        </div>

        <!-- Uploaded files -->
        <div>
          <h4>Uploaded Files</h4>
          <vaadin-upload id="ssdResourceUpload" on-upload-before="fileupload" files="[[resource.uploadedFiles]]"></vaadin-upload>
          <!-- <iron-icon slot="drop-label-icon" icon="description"></iron-icon> -->
          <span slot="drop-label"></span>

        </div>

        <!-- default and custom images -->
        <div style="display: flex">
          <div>
            <h4>Default Image</h4>
            <img src="[[resource.featureImage]]" class="feature-image placeholder" hidden$=[[!resource.featureImage]]>
            <div class="feature-image placeholder" hidden$=[[resource.featureImage]]>Specify a resource type</div>
          </div>
          <div style="margin-left:20px">
            <h4>Custom Image</h4>
            <img src="[[resource.customImage]]" class="feature-image" hidden$=[[!resource.customImage]]>
            <div class="feature-image placeholder" hidden$=[[resource.customImage]]>
              <vaadin-upload class="image-drop" max-files="1" id="featureImageUpload" on-upload-before="featureImageUpload" nodrop>
              </vaadin-upload>
            </div>

          </div>
        </div>

      </paper-card>

      <!-- resource preview -->
      <resource-element resource="[[resource]]" hidden$="[[!previewMode]]" class="resource-preview"></resource-element>
    </div>

  </template>

  <script>
    class ResourceEditor extends ReduxMixin(Polymer.Element) {
      static get is() { return 'resource-editor'; }
      static get properties() {
        return {
          path: {
            type: String,
            statePath: 'path',
          },
          allResourcesBySlug: {
            type: Object,
            statePath: 'persistedResources.bySlug'
          },
          resource: {
            type: Object,
            computed: '_setActiveResource(path,allResourcesBySlug)'
          },
          allKeywordsArray: {
            type: Array,
            statePath: 'persistedTags.array.keywords'
          },
          allKeywordsByKey: {
            type: Object,
            statePath: 'persistedTags.byKey.keywords',
          },
          allResourceTypesArray: {
            type: Array,
            statePath: 'persistedTags.array.resourceTypes',
          },
          allResourceTypesByKey: {
            type: Object,
            statePath: 'persistedTags.byKey.resourceTypes',
          },
          previewMode: {
            type: Boolean,
            value: true
          },
          keywordFilterText: {
            type: String,
            observer: '_showAddKeywordText'
          }


          // slug: {
          //   type: String,
          //   computed: '_toSlug(resource.name)'
          // },
          // origin: {
          //   type: String,
          //   value: function () { return window.origin + '/resource' }
          // },
          // externalLinkUrl: {
          //   type: String,
          //   value: ''
          // }
        };
      }
      static get observers() {
        return [
          '_setResourceSlug(resource.name)',
          '_setFeatureImage(resource.type,allResourceTypesByKey)',
          '_listKeywords(resource.keywords,allKeywordsByKey)',
          '_resourceChanged(resource)',


        ]
      }
      static get actions() {
        return {
          updateTags(payload) {
            return {
              type: 'UPDATE_TAGS',
              payload: payload
            }
          }
        }
      }

      connectedCallback() {
        // binding enter key for external link input
        super.connectedCallback();
        this.target = this.$.externalLinkInput
      }

      _resourceChanged(resource) { console.log('resource changed', this.resource) }

      _listKeywords(resourceKeywords, allKeywordsByKey) {
        if (resourceKeywords && allKeywordsByKey) {
          let resourceKeywordsArray = []
          Object.keys(resourceKeywords).map(
            k => {
              resourceKeywordsArray.push(this.allKeywordsByKey[k])
            }
          )
          this.set('resourceKeywordsArray', resourceKeywordsArray)
        }
      }

      _onFileInputChange(e) {
        let files = e.target.inputElement.inputElement.files
        console.log('file input change', files)
        this.set('fileArray', files)
        console.log('file array', this.fileArray)
      }

      _setActiveResource(path, allResourcesBySlug) {
        // if path contains a resource (/resources/resourceSlug), load it
        if (path && path.split('/')[2] && allResourcesBySlug) {
          // load existing for editing
        }
        // otherwise create new blank resource
        else {
          console.log('set active resource path', this.resource)
          if (!this.resource) {
            let resource = this._createNewResource()
            return resource
          }
          else { return this.resource }

        }
      }

      _createNewResource() {
        let id = this.generatePushID();
        var d = Date.now()
        var shortcode = this.generateShortCode()
        let newResource = {
          $key: id,
          shortcode: shortcode,
          description: '',
          name: '',
          keywords: {},
          uploadedFiles: [],
          externalLinks: [],
          created: d,
          modified: '',
          editedBy: {},
          featureImage: null,
          type: null,
          deleted: false,
          public: true,
          draft: true
        }
        return newResource
      }

      _setResourceSlug(name) {
        if (!name) {
          //new resource
          // this.resource.slug = ""
          // this.slug = ''
        }
        else {
          this.origin = window.origin
          //could definitely be combined into one expression but I suck at regex :( 
          //make lower case, replace all spaces with '-' and remove special
          var slug = name.toLowerCase().replace(/\s+/g, '-').replace(/[^0-9a-z-]/g, "");
          this.resource.slug = slug
          this.slug = slug
        }

      }

      _setFeatureImage(resourceType) {
        if (resourceType) {
          let type = this.allResourceTypesByKey[resourceType]
          //setting it as local image, could also set it to hosted image url
          this.set('resource.featureImage', 'images/resourceTypes/' + type.slug + '.jpg')
        }
        // else {
        //   // default image - currently null with placeholder
        //   return ''
        // }
      }

      _addKeyword(e, keywordID = null) {
        if (!keywordID) { keywordID = e.target.value }
        this.set('resource.keywords.' + keywordID, true)
        this._listKeywords(this.resource.keywords, this.allKeywordsByKey)
        this.selectedKeyword = null
      }

      _addNewKeyword(e) {
        e.preventDefault()
        // only run if text specified
        if (e.detail) {
          // convert to Title Case (capital each word)
          let label = this._toTitleCase(e.detail)
          let keyword = {
            type: 'Keyword',
            label: label,
            modified: Date.now(),
            slug: this._toSlug(label),
            key: this.generatePushID()
          }
          // set the firebase payload doc to the desired data
          this.set('firebaseDocData', keyword)
          // set the path and id for the data and update data at the same time
          this.$.firebaseDoc.saveValue('/tags/Keywords', keyword.key).then(
            () => {
              // the change in keywords is automatically caugh by a deep observer on the main stats4sd-app element and 
              // should refelct the state through. That way we can just add the keyword the same way as if in the dropdown menu originally
              this._addKeyword(null, keyword.key)
            }
          )
        }
      }

      _removeKeyword(e) {
        try {
          let keywordID = JSON.parse(e.target.dataset.keyword).$key
          if (this.resource.keywords.hasOwnProperty(keywordID)) {
            delete this.resource.keywords[keywordID]
          }
          this.notifyPath('resource.keywords')
        } catch (error) {
        }
      }

      _toSlug(name) {
        if (!name) { return "" }
        else {
          var slug = name.toLowerCase().replace(/\s+/g, '-').replace(/[^0-9a-z-]/g, "");
          return slug
        }
      }
      _toTitleCase(str) {
        return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
      }

      generatePushID() {
        var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
        var lastPushTime = 0;
        var lastRandChars = [];
        var now = new Date().getTime();
        var duplicateTime = (now === lastPushTime);
        lastPushTime = now;
        var timeStampChars = new Array(8);
        for (var i = 7; i >= 0; i--) {
          timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
          now = Math.floor(now / 64);
        }
        if (now !== 0) throw new Error('We should have converted the entire timestamp.');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
          for (i = 0; i < 12; i++) {
            lastRandChars[i] = Math.floor(Math.random() * 64);
          }
        } else {
          for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
            lastRandChars[i] = 0;
          }
          lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
          id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        if (id.length != 20) throw new Error('Length should be 20.');
        return id;
      }

      generateShortCode() {
        var text = "";
        var possible = "ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnpqrstuvwyz123456789";
        for (var i = 0; i < 4; i++)
          text += possible.charAt(Math.floor(Math.random() * possible.length));
        return text;
      }

      _togglePreview() { this.previewMode = !this.previewMode }

      _showAddKeywordText(filterText) {
        // quick method that checks the number of available filtered keywords when text input is changed
        // prompting the user to press enter to add a new keyword if none are available, displaying as title case
        if (filterText.length > 0 && this.$.keywordsCombo.filteredItems.length == 0) {
          this.showAddKeywordText = true
          this.keywordFilterText = this._toTitleCase(this.keywordFilterText)
        }
        else { this.showAddKeywordText = false }
      }

      selectedKeywordChanged(k) {
        console.log('k', k)
      }


      _addExternalLink(e) {
        if (!this.resource.externalLinks) {
          this.set('resource.externalLinks', [])
        }
        if (this.externalLinkUrl != '') {
          this.push('resource.externalLinks', {
            displayName: "",
            url: this.externalLinkUrl
          })
        }
        this.set('externalLinkUrl', "")
        console.log('resource', this.resource)
      }
      removeLink(e) {
        var index = e.model.index;
        this.splice('resource.externalLinks', index, 1)
      }
      editLink(e) {
        this.set('externalLinkUrl', e.model.link.url)
        this.removeLink(e)
      }


      // fileupload(event) {
      //   event.preventDefault();
      //   //check resource name exists, give warning and remove files if not
      //   //*******not implemented yet*****

      //   //create file upload task
      //   let file = event.detail.file;
      //   let ssdResourcesApp = firebase.app('stats4sd-resources')
      //   let ref = firebase.storage(ssdResourcesApp).ref().child('/resources/' + this.resource.$key + "/" + file.name)
      //   let uploadTask = ref.put(file);
      //   //handle updates from snapshot
      //   uploadTask.on('state_changed', function (snapshot) {
      //     let progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
      //     let vaadinUploads = document.querySelector('vaadin-upload')
      //     let index = this.getCurrentIndex(file.name)
      //     let temp = this.resource.uploadedFiles[index]
      //     temp.progress = progress
      //     this.set('resource.uploadedFiles.' + index, [])
      //     this.set('resource.uploadedFiles.' + index, temp)
      //   }.bind(this), function (error) {
      //     console.log('error', error)
      //     // Handle unsuccessful uploads
      //   }, function () {
      //     let index = this.getCurrentIndex(file.name);
      //     console.log('index', index)
      //     console.log('res', this.resource.uploadedFiles)
      //     let res = this.resource.uploadedFiles[index]
      //     console.log('res', res)
      //     let temp = {
      //       lastModified: res.lastModified,
      //       name: res.name,
      //       size: res.size,
      //       type: res.type,
      //       url: uploadTask.snapshot.downloadURL,
      //       complete: true,
      //       formDataName: "file",
      //       progress: 100,
      //     }
      //     this.set('resource.uploadedFiles.' + index, [])
      //     this.set('resource.uploadedFiles.' + index, temp)
      //     console.log('resource', this.resource)
      //   }.bind(this));
      // }
      // getCurrentIndex(fileName) {
      //   var uploads = this.resource.uploadedFiles
      //   for (var i = 0; i < uploads.length; i++) {
      //     if (uploads[i].name == fileName) { return i }
      //   }
      // }

    }

    window.customElements.define(ResourceEditor.is, ResourceEditor);
  </script>
</dom-module>


<!-- unused html


<paper-input type="file" id "customImageFile" on-change="_onFileInputChange"></paper-input>
        <firebase-storage-multiupload path="/test" files="[[fileArray]]" upload-tasks="{{uploadTasks}}">
        </firebase-storage-multiupload>
        <template is="dom-repeat" items="[[uploadTasks]]">
          <firebase-storage-upload-task task="[[item]]" bytes-transferred="{{item.bytesTransferred}}" total-bytes="{{item.totalBytes}}"
            state="{{item.state}}" download-url="{{item.downloadUrl}}" metadata="{{item.metadata}}" path="{{item.path}}">
          </firebase-storage-upload-task>
          <div>task:[[item]], transferred:[[item.bytesTransferred]]</div>
        </template>
      
      -->