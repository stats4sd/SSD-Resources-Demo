<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../redux-mixin.html">

<link rel="import" href="../../bower_components/polymerfire/firebase-storage-multiupload.html">
<link rel="import" href="../../bower_components/polymerfire/firebase-storage-upload-task.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-card/paper-card.html">
<link rel="import" href="../../bower_components/paper-toggle-button/paper-toggle-button.html">
<link rel="import" href="../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../bower_components/vaadin-combo-box/vaadin-combo-box.html">
<link rel="import" href="../../bower_components/vaadin-upload/vaadin-upload.html">
<link rel="import" href="../../bower_components/iron-icons/social-icons.html">

<link rel="import" href="../ssd-elements/resource-element.html">
<link rel="import" href="../shared-styles.html">
<link rel="import" href="../stats4sd-icons.html">


<dom-module id="resource-editor">
  <template>
    <style include="shared-styles">
      :host {
        display: block;
        padding: 10px;
      }

      .resource-preview {
        border: 1px solid black;
        flex: 1;
        margin-left: 20px;
      }

      paper-toggle-button.preview-toggle {
        float: right;
        cursor: pointer;
        --paper-toggle-button-checked-bar-color: var(--paper-green-500);
        --paper-toggle-button-checked-button-color: var(--paper-green-500);
        --paper-toggle-button-checked-ink-color: var(--paper-green-500);
      }

      .preview-toggle-label {
        float: right;
        font-size: small;
        padding-right: 5px;
        cursor: pointer;
      }
    </style>

    <!-- Firebase binding for live tag data -->
    <!-- <firebase-document path="/tags" data="{{liveTags}}" app-name="stats4sd-firebase"></firebase-document>
    <firebase-document id="currentTag" app-name="stats4sd-firebase" data="{{currentTag}}" path=""></firebase-document> -->
    <div style="display: flex;flex-wrap:wrap">
      <paper-card style="padding:10px; width: 350px;">
        <paper-toggle-button checked="{{previewMode}}" class="preview-toggle"></paper-toggle-button>
        <div class="preview-toggle-label" on-tap="_togglePreview">Preview</div>
        <!-- Title and Description -->
        <paper-input id="resourceName" value="{{resource.name}}" name="title" label="Title of Resource" required></paper-input>
        <span class="url">[[origin]]/[[slug]]</span>
        <p>
          <paper-textarea id="resourceDescription" value="{{resource.description}}" name="description" label="Brief Description" required
            always-float-label></paper-textarea>
        </p>

        <!-- *** Need save function to track tags saved, possibly linked to combo change event to populate resource tags -->

        <!-- Tags -->
        <vaadin-combo-box label="Keywords" id="Keywords_Combo" items="[[allKeywordsArray]]" item-value-path="$key" allow-custom-value
          on-custom-value-set="_addNewTag" on-change="_comboChange">
        </vaadin-combo-box>
        <template id="keywordsList" is="dom-repeat" as="tag" items="[[resource.tags.keywords]]">
          <paper-button class="tag-button">{{tag.label}}
            <iron-icon icon="close" on-tap="removeTag"></iron-icon>
          </paper-button>
        </template>
        <vaadin-combo-box label="Resource Type" id="Resource-Types_Combo" items="[[allResourceTypesArray]]" item-label-path="label"
          item-value-path="$key" value="{{resource.type}}">
        </vaadin-combo-box>


        <!-- **************************** possibly manage collections elsewhere? ************************ -->
        <!-- External Links -->
        <div style="margin-bottom:1em">
          <h4 style="margin-bottom: 0">External Links</h4>
          <template id="externalLinks" is="dom-repeat" items="[[resource.externalLinks]]" as="link">
            <div class='flex-container'>
              <a href="{{link.url}}" target="_blank">
                <span>[[link.url]]</span>
              </a>
              <paper-icon-button suffix on-tap="editLink" class="green" icon="mode-edit" alt="edit" title="edit">
              </paper-icon-button>
              <paper-icon-button on-tap="removeLink" class="red" icon="clear" alt="clear" title="clear">
              </paper-icon-button>
            </div>
          </template>
          <div style="display:flex; align-items:center">
            <iron-icon icon="social:public" prefix style="margin-right:5px"></iron-icon>
            <paper-input style="flex-basis:100%" label="add external links here" no-label-float value="{{externalLinkUrl}}"></paper-input>
            <paper-icon-button suffix on-tap="_addExternalLink" style="color:green" icon="add" alt="add" title="add"></paper-icon-button>
          </div>
        </div>

        <!-- Draft/Published Checkbox -->
        <div class="flex">
          <paper-toggle-button checked="{{!resource.draft}}"></paper-toggle-button>
          <div hidden$="[[resource.draft]]">
            <span>Public</span>
            <iron-icon icon="visibility"></iron-icon>
          </div>
          <div hidden$="[[!resource.draft]]">
            <span>Draft</span>
            <iron-icon icon="visibility-off"></iron-icon>
          </div>
        </div>

        <h4>Uploaded Files</h4>
        <vaadin-upload id="ssdResourceUpload" on-upload-before="fileupload" files="[[resource.uploadedFiles]]"></vaadin-upload>
        <iron-icon slot="drop-label-icon" icon="description"></iron-icon>
        <span slot="drop-label"></span>

        <!-- default and custom images -->
        <div style="display: flex">
          <div>
            <h4>Default Image</h4>
            <img src="[[resource.featureImage]]" style="max-width:200px">
          </div>
          <div style="margin-left:20px">
            <h4>Custom Image</h4>
            <img src="[[resource.customImage]]" style="max-width:200px">
            <vaadin-upload class="image-drop" max-files="1" id="featureImageUpload" on-upload-before="featureImageUpload" nodrop>
            </vaadin-upload>
            <!-- <paper-input type="file" id "customImageFile" on-change="_onFileInputChange"></paper-input>
        <firebase-storage-multiupload path="/test" files="[[fileArray]]" upload-tasks="{{uploadTasks}}">
        </firebase-storage-multiupload>
        <template is="dom-repeat" items="[[uploadTasks]]">
          <firebase-storage-upload-task task="[[item]]" bytes-transferred="{{item.bytesTransferred}}" total-bytes="{{item.totalBytes}}"
            state="{{item.state}}" download-url="{{item.downloadUrl}}" metadata="{{item.metadata}}" path="{{item.path}}">
          </firebase-storage-upload-task>
          <div>task:[[item]], transferred:[[item.bytesTransferred]]</div>
        </template> -->
          </div>
        </div>

      </paper-card>

      <!-- resource preview -->
      <resource-element resource="[[resource]]" hidden$="[[!previewMode]]" class="resource-preview"></resource-element>
    </div>

  </template>

  <script>
    class ResourceEditor extends ReduxMixin(Polymer.Element) {
      static get is() { return 'resource-editor'; }
      static get properties() {
        return {
          path: {
            type: String,
            statePath: 'path',
          },
          allResourcesBySlug: {
            type: Object,
            statePath: 'persistedResources.bySlug'
          },
          resource: {
            type: Object,
            computed: '_setActiveResource(path,allResourcesBySlug)'
          },
          allKeywordsArray: {
            type: Array,
            statePath: 'persistedTags.array.keywords'
          },
          allResourceTypesArray: {
            type: Array,
            statePath: 'persistedTags.array.resourceTypes',
          },
          allResourceTypesByKey: {
            type: Object,
            statePath: 'persistedTags.byKey.resourceTypes',
          },
          previewMode: {
            type: Boolean,
            value: true
          }


          // slug: {
          //   type: String,
          //   computed: '_toSlug(resource.name)'
          // },
          // origin: {
          //   type: String,
          //   value: function () { return window.origin + '/resource' }
          // },
          // externalLinkUrl: {
          //   type: String,
          //   value: ''
          // }
        };
      }
      static get observers() {
        return [
          '_setResourceSlug(resource.name)',
          '_setFeatureImage(resource.type,allResourceTypesByKey)',
        ]
      }

      _onFileInputChange(e) {
        let files = e.target.inputElement.inputElement.files
        console.log('file input change', files)
        this.set('fileArray', files)
        console.log('file array', this.fileArray)
      }

      _setActiveResource(path, allResourcesBySlug) {
        // if path contains a resource (/resources/resourceSlug), load it
        if (path && path.split('/')[2] && allResourcesBySlug) {
          // load existing for editing
        }
        // otherwise create new blank resource
        else {
          return this._createNewResource()
        }
      }

      _generateEmptyResource() {
        return {
          name: 'test'
        }
      }
      _createNewResource() {
        let id = this.generatePushID();
        console.log('creating new resource', id)
        var d = Date.now()
        var shortcode = this.generateShortCode()
        let newResource = {
          $key: id,
          shortcode: shortcode,
          description: '',
          name: '',
          tags: {},
          uploadedFiles: [],
          externalLinks: [],
          created: d,
          modified: '',
          editedBy: {},
          featureImage: '',
          type: null,
          deleted: false,
          draft: false
        }
        console.log('new resource', newResource)
        return newResource
      }

      generatePushID() {
        var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
        var lastPushTime = 0;
        var lastRandChars = [];
        var now = new Date().getTime();
        var duplicateTime = (now === lastPushTime);
        lastPushTime = now;
        var timeStampChars = new Array(8);
        for (var i = 7; i >= 0; i--) {
          timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
          now = Math.floor(now / 64);
        }
        if (now !== 0) throw new Error('We should have converted the entire timestamp.');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
          for (i = 0; i < 12; i++) {
            lastRandChars[i] = Math.floor(Math.random() * 64);
          }
        } else {
          for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
            lastRandChars[i] = 0;
          }
          lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
          id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        if (id.length != 20) throw new Error('Length should be 20.');
        return id;
      }

      generateShortCode() {
        var text = "";
        var possible = "ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijklmnpqrstuvwyz123456789";
        for (var i = 0; i < 4; i++)
          text += possible.charAt(Math.floor(Math.random() * possible.length));
        return text;
      }

      _setResourceSlug(name) {
        this.origin = window.origin
        if (!name) {
          //new resource
          this.resource.slug = ""
          this.slug = ''
        }
        else {
          //could definitely be combined into one expression but I suck at regex :( 
          //make lower case, replace all spaces with '-' and remove special
          var slug = name.toLowerCase().replace(/\s+/g, '-').replace(/[^0-9a-z-]/g, "");
          this.resource.slug = slug
          this.slug = slug
        }

      }

      _setFeatureImage(resourceType) {
        console.log('setting feature image', resourceType)
        if (resourceType) {
          let type = this.allResourceTypesByKey[resourceType]
          //setting it as local image, could also set it to hosted image url
          this.set('resource.featureImage', 'images/resourceTypes/' + type.slug + '.jpg')
          // this.set('resource.featureImage',type.image)
          console.log('resource', this.resource)
        }
        else {
          return ''
        }
      }

      _togglePreview() { this.previewMode = !this.previewMode }


      // }
      // _computeItems(tags, key) {
      //   // take liveTags, select subset and put into correct format (un-nest json)
      //   let items = tags[key]
      //   let temp = []
      //   for (let key in items) {
      //     let t = items[key]
      //     t.key = key
      //     temp.push(t)
      //   }
      //   return temp
      // }

      // _addNewTag(e) {
      //   let type = e.target.id.split('_')[0]
      //   let label = e.target.filter
      //   let tag = {
      //     type: type,
      //     label: label,
      //     modified: Date.now(),
      //     slug: this._toSlug(label),
      //     key: this.generatePushID()
      //   }
      //   console.log('saving tag', tag)
      //   let path = "/tags/" + type
      //   this.set('currentTag', tag)
      //   this.$.currentTag.saveValue(path, tag.key).then(function () {
      //     //populate element
      //     this.updateResourceTags(tag.key, this.currentTag, type)
      //     this.$.currentTag.reset()
      //   }.bind(this));
      // }

      // removeTag(e) {
      //   // remove keyword tag bound to resource
      //   // to generalise see older versions, or look at binding to e.target for info
      //   var key = e.model.tag.key
      //   delete this.resource.tags.Keywords[key]
      //   //dirty override as doesn't detect when all tags removed
      //   let tags = this.resource.tags
      //   this.set('resource.tags', {})
      //   this.set('resource.tags', tags)
      // }
      // _comboChange(e) {
      //   // Use combo box change event to populate resource tag. Tracks which field to populate by taking all before '_' in id name
      //   // If no item available then used to create new
      //   let item = e.target.selectedItem
      //   let type = e.target.id.split('_')[0]
      //   if (type == "Keywords") { e.target.value = "" }
      //   // if no item tag will be added through add new tag function called on combo custom value set
      //   if (!item) { return }
      //   let key = item.key
      //   this.updateResourceTags(key, item, type)
      // }
      // updateResourceTags(key, value, type) {
      //   if (!this.resource.hasOwnProperty('tags')) { this.resource.tags = {} }
      //   if (!this.resource.tags.hasOwnProperty(type)) { this.resource.tags[type] = {} }
      //   // override previous resource types if exist (tag unique only for resource types)
      //   if (type == "Resource-Types") { this.resource.tags['Resource-Types'] = {} }
      //   this.resource.tags[type][key] = value
      //   // attempts to get keywords list to update and resource type image to render
      //   let tags = this.resource.tags
      //   this.set('resource.tags', {})
      //   this.set('resource.tags', tags)
      // }
      // _addExternalLink(e) {
      //   if (!this.resource.externalLinks) {
      //     this.set('resource.externalLinks', [])
      //   }
      //   if (this.externalLinkUrl != '') {
      //     this.push('resource.externalLinks', {
      //       displayName: "",
      //       url: this.externalLinkUrl
      //     })
      //   }
      //   this.set('externalLinkUrl', "")
      //   console.log('resource', this.resource)
      // }
      // removeLink(e) {
      //   var index = e.model.index;
      //   this.splice('resource.externalLinks', index, 1)
      // }
      // editLink(e) {
      //   this.set('externalLinkUrl', e.model.link.url)
      //   this.removeLink(e)
      // }
      // _getFeatureImage(tags) {
      //   if (this.resource.featureImageUrl) { return this.resource.featureImageUrl }
      //   console.log('getting feature image', tags)
      //   if (tags && tags.hasOwnProperty('Resource-Types')) {
      //     let key = Object.keys(tags['Resource-Types'])[0]
      //     let url = '/images/resourceTypes/' + tags['Resource-Types'][key].slug + '.jpg'
      //     return url
      //   }
      //   else {
      //     return "/images/resourceTypes/fallback-image.jpg"
      //   }
      // }
      // _tagsToArray(json, subProperty) {
      //   //lookup full tag
      //   if (!json) { return }
      //   if (!json.hasOwnProperty(subProperty)) { return }
      //   let tags = json[subProperty]
      //   var tagsArray = []
      //   for (var key in tags) {
      //     if (tags.hasOwnProperty(key)) {
      //       tagsArray.push(tags[key])
      //     }
      //   }
      //   return tagsArray
      // }

      // fileupload(event) {
      //   event.preventDefault();
      //   //check resource name exists, give warning and remove files if not
      //   //*******not implemented yet*****

      //   //create file upload task
      //   let file = event.detail.file;
      //   let ssdResourcesApp = firebase.app('stats4sd-resources')
      //   let ref = firebase.storage(ssdResourcesApp).ref().child('/resources/' + this.resource.$key + "/" + file.name)
      //   let uploadTask = ref.put(file);
      //   //handle updates from snapshot
      //   uploadTask.on('state_changed', function (snapshot) {
      //     let progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
      //     let vaadinUploads = document.querySelector('vaadin-upload')
      //     let index = this.getCurrentIndex(file.name)
      //     let temp = this.resource.uploadedFiles[index]
      //     temp.progress = progress
      //     this.set('resource.uploadedFiles.' + index, [])
      //     this.set('resource.uploadedFiles.' + index, temp)
      //   }.bind(this), function (error) {
      //     console.log('error', error)
      //     // Handle unsuccessful uploads
      //   }, function () {
      //     let index = this.getCurrentIndex(file.name);
      //     console.log('index', index)
      //     console.log('res', this.resource.uploadedFiles)
      //     let res = this.resource.uploadedFiles[index]
      //     console.log('res', res)
      //     let temp = {
      //       lastModified: res.lastModified,
      //       name: res.name,
      //       size: res.size,
      //       type: res.type,
      //       url: uploadTask.snapshot.downloadURL,
      //       complete: true,
      //       formDataName: "file",
      //       progress: 100,
      //     }
      //     this.set('resource.uploadedFiles.' + index, [])
      //     this.set('resource.uploadedFiles.' + index, temp)
      //     console.log('resource', this.resource)
      //   }.bind(this));
      // }
      // getCurrentIndex(fileName) {
      //   var uploads = this.resource.uploadedFiles
      //   for (var i = 0; i < uploads.length; i++) {
      //     if (uploads[i].name == fileName) { return i }
      //   }
      // }

    }

    window.customElements.define(ResourceEditor.is, ResourceEditor);
  </script>
</dom-module>